/*
 * Copyright (C) 2007 by
 * 
 * 	Xuan-Hieu Phan
 *	hieuxuan@ecei.tohoku.ac.jp or pxhieu@gmail.com
 * 	Graduate School of Information Sciences
 * 	Tohoku University
 *
 * GibbsLDA++ is a free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2 of the License,
 * or (at your option) any later version.
 *
 * GibbsLDA++ is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GibbsLDA++; if not, write to the Free Software Foundation,
 * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 */

/* 
 * References:
 * + The Java code of Gregor Heinrich (gregor@arbylon.net)
 *   http://www.arbylon.net/projects/LdaGibbsSampler.java
 * + "Parameter estimation for text analysis" by Gregor Heinrich
 *   http://www.arbylon.net/publications/text-est.pdf
 */

#include "model.h"
using namespace Rcpp;

void model::set_default_values() {
   
    this->M = 0;
    this->V = 0;
    this->K = 100;
    this->alpha = 50.0 / K;
    this->beta = 0.1;
    this->niters = 2000;
    this->liter = 0;
    
}

void model::set_data(arma::sp_mat mt) {
    this->data = mt;
    this->V = (int)mt.n_cols; 
    this->M = (int)mt.n_rows;
    printf("M = %d, V = %d\n", this->M, this->V);
}

int model::init_est() {
    
    this->p = arma::vec(K);
    this->nw = arma::umat(V, K, arma::fill::zeros);
    this->nd = arma::umat(M, K, arma::fill::zeros);
	this->nwsum = arma::urowvec(K, arma::fill::zeros);
    this->ndsum = arma::conv_to<arma::ucolvec>::from(arma::mat(arma::sum(data, 1)));
    this->z = Texts(M);
    
    srandom(time(0)); // initialize for random number generation
    for (int m = 0; m < M; m++) {
        
        int N = this->ndsum[m]; 
        this->z[m] = Text(N);
        
        // initialize for z
        int n = 0;
        arma::sp_mat::const_row_iterator it = data.begin_row(m);
        arma::sp_mat::const_row_iterator it_end = data.end_row(m);
        for(; it != it_end; ++it) {
            int F = *it;
            int w = it.col();
            for (int f = 0; f < F; f++) {
                int topic = (int)(((double)random() / RAND_MAX) * K);
                this->z[m][n] = topic;
                // number of instances of word i assigned to topic j
                this->nw(w, topic) += 1;
                // number of words in document i assigned to topic j
                this->nd(m, topic) += 1;
                // total number of words assigned to topic j
                this->nwsum[topic] += 1;
                n++;
            }
        }
    }
    
    this->theta = arma::mat(M, K, arma::fill::zeros);
	this->phi = arma::mat(K, V, arma::fill::zeros);
    return 0;
}

void model::estimate() {
    
    printf("Sampling %d iterations!\n", niters);
    
    int last_iter = this->liter;
    for (liter = last_iter + 1; liter <= niters + last_iter; liter++) {
    	printf("Iteration %d ...\n", liter);
    	
    	// for all z_i
    	for (int m = 0; m < M; m++) {
    	    int n = 0;
    	    arma::sp_mat::const_row_iterator it = data.begin_row(m);
    	    arma::sp_mat::const_row_iterator it_end = data.end_row(m);
    	    for(; it != it_end; ++it) {
    	        int F = *it;
    	        int w = it.col();
    	        for (int f = 0; f < F; f++) {
    	            this->z[m][n] = this->sampling(m, n, w);
    	            n++;
    	        }
    	    }
    	}
    }
    
    printf("Gibbs sampling completed!\n");
    printf("Saving the final model!\n");
    this->compute_theta();
    this->compute_phi();
    this->liter = last_iter - 1;

}

int model::sampling(int m, int n, int w) {
    
    // remove z_i from the count variables
    int topic = this->z[m][n];
    this->nw(w, topic) -= 1;
    this->nd(m, topic) -= 1;
    this->nwsum[topic] -= 1;
    this->ndsum[m] -= 1;

    double Vbeta = V * this->beta;
    double Kalpha = K * this->alpha;    
    // do multinomial sampling via cumulative method
    for (int k = 0; k < K; k++) {
        this->p[k] = (this->nw(w, topic) + this->beta) / (this->nwsum[k] + Vbeta) *
    		         (this->nd(m, topic) + this->alpha) / (this->ndsum[m] + Kalpha);
    }
    // cumulate multinomial parameters
    for (int k = 1; k < K; k++) {
	    this->p[k] += this->p[k - 1];
    }
    // scaled sample because of unnormalized p[]
    double u = ((double)random() / RAND_MAX) * this->p[K - 1];
    
    for (topic = 0; topic < K; topic++) {
    	if (this->p[topic] > u) {
    	    break;
    	}
    }
    
    // add newly estimated z_i to count variables
    this->nw(w, topic) += 1;
    this->nd(m, topic) += 1;
    this->nwsum[topic] += 1;
    this->ndsum[m] += 1;    
    
    return topic;
}

void model::compute_theta() {
    for (int m = 0; m < M; m++) {
    	for (int k = 0; k < K; k++) {
    	    this->theta(m, k) = (this->nd(m, k) + this->alpha) / (ndsum[m] + K * this->alpha);
    	}
    }
}

void model::compute_phi() {
    for (int k = 0; k < K; k++) {
    	for (int w = 0; w < V; w++) {
    	    this->phi(k, w) = (this->nw(w, k) + this->beta) / (nwsum[k] + V * this->beta);
    	}
    }
}
